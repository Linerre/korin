#+TITLE:  Stanford CS106X

* Info
Note that the course was [[https://explorecourses.stanford.edu/search?view=catalog&filter-coursestatus-Active=on&page=0&catalog=&academicYear=20232024&q=CS106X+Programming+Abstractions+%28Accelerated%29&collapse=][Last offered: Autumn 2019 | UG Reqs: GER:DB-EngrAppSci, WAY-FR]].

Other information about the course:
- site(2019): https://web.stanford.edu/class/cs106x/
- reader: https://web.stanford.edu/class/cs106x/res/reader/CS106BX-Reader.pdf
- old(2017): https://web.stanford.edu/class/archive/cs/cs106x/cs106x.1182/lectures.shtml
  Not recommended as most stuff on this site have turned inaccessible.
- Stanford C++ Libraries: http://www.martinstepp.com/cppdoc/

* 02 Functions
In C++, functions' parameters are passed by value (by default).  If I ever want a pass-by-reference, I will need ~&~ sign:
#+BEGIN_SRC cpp
void setToZero(int & var) {
  var = 0;
}

// Note when calling this function, I DO NOT need to prepend `&' to the argument
int age = 20;
setToZero(age)
//        ^ NO `&' before the arg
#+END_SRC

While in Rust it must be explicitly written as a reference and dereference the var to change its value:
#+BEGIN_SRC rust
fn set_to_zero(var: &mut u32) {
    ,*var = 0;
}

fn main() {
    let mut var = 24u32;
    set_to_zero(&mut var);
}
#+END_SRC
Run the above Rust code using [[https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=dc65be2601b5aab6aef8133d7e832e2a][playground]].

* 03 Strings
Explicitly include ~<string>~ even though ~<iostream>~ has done so:
#+BEGIN_SRC cpp
#include <iostream>  // it includes <string>
using namespace std;

string name = "c++"; // note the string comes seemingly out of thin air
#+END_SRC

Yet the above is not guaranteed and it's better to do this:
#+BEGIN_SRC cpp
#include <iostream>
#include <string>
using namespace std;

string name = "c++"; // note the string comes seemingly out of thin air
#+END_SRC
See [[https://stackoverflow.com/questions/33349833/can-stdstring-be-used-without-include-string][discussions]] on Stack Overflow.

To convert a single ~char~ to C++ string, it's easy to use the ~string~ constructor:
#+BEGIN_SRC cpp
#include <string>

char c = 'A';
std::string apple(1, c); // "A"
#+END_SRC
Read:
1. cpp reference: basic string
2. Stack Overflow: https://stackoverflow.com/questions/17201590/how-can-i-create-a-string-from-a-single-character

* 15 Maps
** 15.3 Hashing
*** Determining the number of buckets
A small number of buckets is more likely to cause collision.

If N_{bucket} < N_{entries}, then collision is inevitable.


The concept of *load factor threshold* can be used as a common technique to dynamically resize a data structure so that its capacity enlarges properly before it has to.

Thumb of rule: load_factor (lambda) <= 0.7 leads to O(1) time complexity when looking up a key in a HashMap (pp.673).
